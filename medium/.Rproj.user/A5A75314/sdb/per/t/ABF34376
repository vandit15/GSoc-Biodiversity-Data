{
    "collab_server" : "",
    "contents" : "# define Markov Chain class\nsetClass(\"markovchain\", # class name\n         \n         # Define the slots\n         slots = list(states = \"character\", byrow = \"logical\",\n                      transitionMatrix = \"matrix\", name = \"character\"),\n         \n         # Set the default values for the slots\n         prototype = list(states = c(\"a\",\"b\"), byrow = TRUE, \n                          transitionMatrix = matrix(data = c(0,1,1,0),\n                                                    nrow = 2, byrow = TRUE, \n                                                    dimnames = list(c(\"a\",\"b\"), c(\"a\",\"b\"))),  \n                          name = \"Unnamed Markov chain\")\n)\n\n# initializing method for markovchain objects\nsetMethod(\"initialize\",\n          signature(.Object = \"markovchain\"),\n          function (.Object, states, byrow, transitionMatrix, name, ...) {\n            \n            # put the standard markovchain \n            if(missing(transitionMatrix)) {\n              transitionMatrix <- matrix(data = c(0, 1, 1, 0),\n                                         nrow = 2,\n                                         byrow = TRUE, \n                                         dimnames = list(c(\"a\",\"b\"), c(\"a\",\"b\"))\n              ) \n            }\n            \n            # check names of transition matrix\n            # if all names are missing it initializes them to \"1\", \"2\", ....\n            \n            if(all(is.null(rownames(transitionMatrix)), is.null(colnames(transitionMatrix))) == TRUE) { \n              \n              if(missing(states)) {\n                nr <- nrow(transitionMatrix)\n                stateNames <- as.character(seq(1:nr))\n              } else {stateNames <- states}\n              \n              rownames(transitionMatrix) <- stateNames\n              colnames(transitionMatrix) <- stateNames\n              \n            } else if(is.null(rownames(transitionMatrix))) { # fix when rownames null\n              \n              rownames(transitionMatrix) <- colnames(transitionMatrix)\n              \n            } else if(is.null(colnames(transitionMatrix))) { # fix when colnames null\n              \n              colnames(transitionMatrix) <- rownames(transitionMatrix)\n              \n            } else if(!setequal(rownames(transitionMatrix), colnames(transitionMatrix)))  {\n              \n              colnames(transitionMatrix) <- rownames(transitionMatrix) # fix when different\n              \n            }\n            \n            if(missing(states)) {\n              states <- rownames(transitionMatrix)\n            }\n            \n            if(missing(byrow)) {\n              byrow <- TRUE\n            }\n            \n            if(missing(name)) {\n              name <- \"Unnamed Markov chain\" \n            }\n            \n            callNextMethod(.Object, states = states, byrow = byrow, \n                           transitionMatrix = transitionMatrix, name = name, ...)\n          }\n)\n\n# define Markov Chain List class\nsetClass(\"markovchainList\", \n         slots = list(markovchains = \"list\", \n\t\t                  name = \"character\")\n)\n\n# verifies if a markovchainList object is valid or not\nsetValidity(\"markovchainList\",\n\t\t         function(object) {\n\t\t           check <- FALSE \n\t\t           for(i in 1:length(object@markovchains)) {\n\t\t\t            if(class(object@markovchains[[i]]) != \"markovchain\") {\n\t\t\t              # All elements in the list should be a markovchain object \n\t\t\t              check <- \"Error! All elements should be of class 'markovchain'\" \n\t\t\t            }\n\t\t           }\n\t\t           \n\t\t           if(check == FALSE) check <- TRUE\n\t\t           return(check)\n\t           }\n)\n\n# generic method to print out states\n\n#' @name states\n#' \n#' @title Defined states of a transition matrix\n#' \n#' @description This method returns the states of a transition matrix.\n#' \n#' @param object A discrete \\code{markovchain} object\n#' @return The character vector corresponding to states slot.\n#' \n#' @references A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010\n#' \n#' @author Giorgio Spedicato\n#' \n#' @seealso \\code{\\linkS4class{markovchain}}\n#' \n#' @examples \n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix =\n#'                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,\n#'                 byrow = TRUE, dimnames=list(statesNames,statesNames)),\n#'                name = \"A markovchain Object\" \n#' )\n#' states(markovB)\n#' \n#' @rdname states\n#' \n#' @export\nsetGeneric(\"states\", function(object) standardGeneric(\"states\"))\n\n#' @rdname states\nsetMethod(\"states\",\"markovchain\", \n          function(object) {\n            out <- object@states\n            return(out)\n          }\n)\n\n#' @title Method to retrieve name of markovchain object  \n#' \n#' @name name\n#' \n#' @description This method returns the name of markovchain object\n#' \n#' @param object A markovchain object\n#' @rdname getName\n#' @author Giorgio Spedicato, Deepak Yadav\n#' \n#' @examples \n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix =\n#'                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,\n#'                 byrow = TRUE, dimnames=list(statesNames,statesNames)),\n#'                name = \"A markovchain Object\" \n#' )\n#' name(markovB)\n#' \n#' @export\nsetGeneric(\"name\", function(object) standardGeneric(\"name\"))\n\n\n#' @rdname getName\nsetMethod(\"name\", \"markovchain\", function(object) {\n  out <- object@name\n  return(out)\n})\n\n#' @title Method to set name of markovchain object\n#' \n#' @name name<-\n#' \n#' @description This method modify the existing name of markovchain object\n#' \n#' @param object A markovchain object\n#' @param value New name of markovchain object\n#' @rdname setName\n#' @author Giorgio Spedicato, Deepak Yadav\n#' \n#' @examples \n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix =\n#'                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,\n#'                 byrow = TRUE, dimnames=list(statesNames,statesNames)),\n#'                name = \"A markovchain Object\" \n#' )\n#' name(markovB) <- \"dangerous mc\"\n#' \n#' @export\nsetGeneric(\"name<-\", function(object, value) standardGeneric(\"name<-\"))\n\n#' @rdname setName\nsetMethod(\"name<-\", \"markovchain\", \n          function(object, value) {\n            object@name <- value\n            object\n          }\n)\n\n# adding a method names: to get names\nsetMethod(\"names\",\"markovchain\", \n          function(x) {\n            out <- x@states\n            return(out)\n          }\n)\n\n# adding a method names: to set names\nsetMethod(\"names<-\", \"markovchain\", \n          function(x, value) {\n            rownames(x@transitionMatrix) <- value\n            colnames(x@transitionMatrix) <- value\n            x@states <- value\n            return(x)\n          }\n)\n\n\n# generic methods to get the dim of a markovchain and markovchainList\n\nsetMethod(\"dim\", \"markovchain\", \n\t\tfunction(x) {\n\t\t\tout <- nrow(x@transitionMatrix)\n\t\t\treturn(out)\n\t\t}\n)\n\nsetMethod(\"dim\", \"markovchainList\", \n\t\tfunction(x) {\n\t\t\t  out <- length(x@markovchains)\n\t\t\t  return(out)\n\t\t  }\n)\n\n\n# method  to set the validity of a markovchain object\nsetValidity(\"markovchain\",\n\t\tfunction(object) {\n\t\t\tcheck <- FALSE\n\t\t\t\n\t\t\t# performs a set of check whose results are saved in check\n\t\t\t\n\t\t\t# check all values of transition matrix belongs to [0, 1]\n\t\t\tif (any(sapply(as.numeric(object@transitionMatrix),.isProbRcpp)) == FALSE) {\n\t\t\t  check <- \"Error! Some elements are not probabilities\"\n\t\t\t}\n\t\t\t\n\t\t\t# rows sum or columns sum = 1\n\t\t\tif (object@byrow == TRUE) {\n\t\t\t  \n\t\t\t  # absolute difference\n\t\t\t  absdiff <- abs(1-rowSums(object@transitionMatrix))\n\t\t\t\t\n\t\t\t  if(any(absdiff > .Machine$double.eps*100)) {\n\t\t\t\t  check <- \"Error! Row sums not equal to one\" \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t  \n\t\t\t  # absolute difference\n\t\t\t  absdiff <- abs(1-colSums(object@transitionMatrix))\n\t\t\t  \n\t\t\t  if(any(absdiff > .Machine$double.eps*10)) {\n\t\t\t\t  check <- \"Error! Col sums not equal to one\"\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t# check whether matrix is square amtrix or not\n\t\t\tif (nrow(object@transitionMatrix) != ncol(object@transitionMatrix)) {\n\t\t\t  check <- \"Error! Not squared matrix\" #check if squalre matrix\n\t\t\t}\n      \n\t\t\t# check whether column names or rows names equal to state names or not\n\t\t\tif (!setequal(colnames(object@transitionMatrix), object@states)) {\n\t\t\t  check <- \"Error! Colnames <> states\" \n\t\t\t}\n      if (!setequal(rownames(object@transitionMatrix), object@states)) {\n        check <- \"Error! Rownames <> states\"\n      }\n\t\t\t\n      if (check == FALSE) {\n        return(TRUE)\n      }  else {\n        return(check)\n      }\n\t\t}\n)\n\n# matr : matrix\n# transpose : boolean indicating whether the matrix shall be transposed or not\n# output : a matrix / vector\n\n.mcEigen <- function(matr, transpose = TRUE) {\n  \n  if (transpose) {\n    tMatr <- t(matr) \n  } else {\n    tMatr <- matr\n  }\n  \n  # perform the eigenvalue extraction\n  eigenResults <- eigen(x = tMatr, symmetric = FALSE) \n  \n  # takes the one eigenvalue\n  onesIndex <- which(round(eigenResults$values,3) == 1) \n  \n  # do the following: \n  # 1 : get eigenvectors whose eigenvalues == 1\n  # 2 : normalize\n  \n  if (length(onesIndex) == 0) {\n    warning(\"No eigenvalue = 1 found\")\n    return(NULL)\n  }\n  \n  if (transpose == TRUE) {\n    eigenTake <- as.matrix(t(eigenResults$vectors[, onesIndex])) \n    out <- eigenTake / rowSums(eigenTake) # normalize\n  } else {\n    eigenTake <- as.matrix(eigenResults$vectors[,onesIndex]) \n    out <- eigenTake / colSums(eigenTake) # normalize\n  }\n  \n  # subset the eigenvectors\n  # normalize\n  # take the real part: need to be sanitized\n\t# @DEEPAK: later we have to see and optimize this part. I am not sure taking\n\t#       the real part is most appropriate.\n  \n  out <- Re(out)\n  return(out)\n}\n\n# method to get stationary states\n\n#' @name steadyStates\n#' @title Stationary states of a \\code{markovchain} objeect\n#' \n#' @description This method returns the stationary vector in matricial form of a markovchain object.\n#' @param object A discrete \\code{markovchain} object\n#' \n#' @return A matrix corresponding to the stationary states\n#' \n#' @references A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010\n#' @author Giorgio Spedicato\n#' @seealso \\code{\\linkS4class{markovchain}}\n#' \n#' @note The steady states are identified starting from which eigenvectors correspond \n#'       to identity eigenvalues and then normalizing them to sum up to unity. When negative values are found \n#'       in the matrix, the eigenvalues extraction is performed on the recurrent classes submatrix.\n#'       \n#' @examples \n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix =\n#'                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,\n#'                 byrow = TRUE, dimnames=list(statesNames,statesNames)),\n#'                name = \"A markovchain Object\" \n#' )       \n#' steadyStates(markovB)\n#' \n#' @rdname steadyStates\n#' @export\nsetGeneric(\"steadyStates\", function(object) standardGeneric(\"steadyStates\"))\n\n#' @rdname steadyStates\nsetMethod(\"steadyStates\",\"markovchain\", \n\t\tfunction(object) {\n\t\t\ttransposeYN <- FALSE\n\t\t\tif(object@byrow == TRUE) {\n\t\t\t  transposeYN <- TRUE\t\t\n\t\t\t}\n      \n\t\t\tout <- .mcEigen(matr = object@transitionMatrix, transpose = transposeYN)\n\t\t\t\n\t\t\t# if any element negative\n\t\t\tif (min(out)<0) {\n\t\t\t  warning(\"Negative elements in steady states, working on closed classes submatrix\")\n\t\t\t  if(object@byrow==TRUE) myObject=object else myObject=t(object)\n\t\t\t  out <- .steadyStatesByRecurrentClasses(object=myObject)\n\t\t\t  if (object@byrow==FALSE) out<-t(out)\n\t\t\t}\n      \n\t\t\tif(is.null(out)) {\n\t\t\t\twarning(\"Warning! No steady state\")\n\t\t\t\treturn(NULL)\n\t\t\t}\n\t\t\n\t\t\t\n\t\t\tif(transposeYN == TRUE) { \n\t\t\t\tcolnames(out) <- object@states\n\t\t\t} else {\n\t\t\t\trownames(out) <- object@states\n\t\t\t}\n\n      return(out)\n    }\n)\n\n\n\n\n#' @title steadyStatesByRecurrent classes\n#' \n#' @description Function to extract steady states when needed\n#' Only recurrent closed classes are considered \n#' @author Christope Dutang and Giorgio Spedicato\n#' @return A matrix\n.steadyStatesByRecurrentClasses<-function(object) {\n  #inizialization\n  M<-object@transitionMatrix\n  #transpose bycol matrices\n  if (object@byrow==FALSE) M <- t(M)\n  namesSequence<-names(object)\n  #characterizin recurrent classes\n  recClasses<-recurrentClasses(object)\n  numRecClasses<-length(recClasses)\n  recurrentClassesNames<-unlist(recClasses)\n  #extracting recurrent classes\n  Msub <- M[rownames(M) %in% recurrentClassesNames, colnames(M) %in% recurrentClassesNames]\n  \n  out<-matrix(0, nrow=numRecClasses, ncol = dim(object))\n  colnames(out)<-names(object)\n  #getting their steady states\n  partialOutput<-t(eigen(Msub)$vectors[,eigen(Msub)$values == 1]) / colSums(eigen(Msub)$vectors[,eigen(Msub)$values == 1])\n  colnames(partialOutput)<-recurrentClassesNames\n  #allocating to their columns\n  out[,colnames(out) %in% recurrentClassesNames]<-partialOutput\n  return(out)\n}\n\n\n# generic function to extract absorbing states\n\n#' @rdname absorbingStates\n#' \n#' @export\nsetGeneric(\"absorbingStates\", function(object) standardGeneric(\"absorbingStates\"))\nsetMethod(\"absorbingStates\", \"markovchain\", \n          function(object) {\n\t\t\t      out <- character()\n\t\t\t      matr <- object@transitionMatrix\n\t\t\t      transposeYN <- FALSE\n\t\t\t      if(object@byrow == TRUE) {\n\t\t\t        transposeYN <- TRUE\n\t\t\t      }\n\t\t\t      \n\t\t\t      steadyStates <- .mcEigen(matr = matr, transpose = transposeYN)\n\t\t\t      if(is.null(steadyStates)) {\n\t\t\t        return(character(0))\n\t\t\t      }\n\t\t\t      \n\t\t\t      # identify which states are absorbing if they are diagonally one\n\t\t\t      if(transposeYN == TRUE) {\n\t\t\t        maxCols <- apply(steadyStates, 2, \"max\")\n\t\t\t      } else {\n\t\t\t        maxCols <- apply(steadyStates, 1, \"max\")  \n\t\t\t      }\n\t\t\t      \n\t\t\t      index <- which(maxCols == 1)\n\t\t\t      if(length(index) > 0) {\n\t\t\t        out <- object@states[index] \n\t\t\t      }\n\t\t\t      \n\t\t\t      return(out)\n          } \n)\n\n# generic method to extract transient states\n\n#' @rdname absorbingStates\n#' \n#' @export\nsetGeneric(\"transientStates\", function(object) standardGeneric(\"transientStates\"))\n\n#' @rdname absorbingStates\nsetMethod(\"transientStates\", \"markovchain\", \n\t       \tfunction(object) {\n\t\t\t      out <- character()\n\t\t\t      \n\t\t\t      # make byRow = true for the matrix\n\t\t\t      if(object@byrow == TRUE) {\n\t\t\t        matr <- object@transitionMatrix\n\t\t\t      } else {\n\t\t\t        matr <- t(object@transitionMatrix)\n\t\t\t      }\n\t\t\t      \n\t\t\t      temp <- .commclassesKernelRcpp(matr)\n\t\t\t      index <- which(temp$v == FALSE)\n\t\t\t      if(length(index) > 0) {\n\t\t\t        out <- names(temp$v[index])\n\t\t\t      }\n\t\t\t      \n\t\t\t      return(out)\n\t\t      }\n)\n\n# generic method to extract transition probability\n# from state t0 to state t1\n\n#' @name transitionProbability\n#' @title Function to get the transition probabilities from initial \n#'        to subsequent states.\n#' @description This is a convenience function to get transition probabilities.\n#' \n#' @param object A \\code{markovchain} object.\n#' @param t0 Initial state.\n#' @param t1 Subsequent state.\n#' \n#' @references A First Course in Probability (8th Edition), \n#'             Sheldon Ross, Prentice Hall 2010\n#' \n#' @return Numeric Vector  \n#' \n#' @author Giorgio Spedicato\n#' @seealso \\code{\\linkS4class{markovchain}}\n#' \n#' @examples \n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix =\n#'                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,\n#'                 byrow = TRUE, dimnames=list(statesNames,statesNames)),\n#'                name = \"A markovchain Object\" \n#' )    \n#' transitionProbability(markovB,\"b\", \"c\")\n#' @rdname transitionProbability\n#'      \n#' @export\nsetGeneric(\"transitionProbability\", function(object, t0, t1) standardGeneric(\"transitionProbability\"))\n\n#' @rdname transitionProbability\nsetMethod(\"transitionProbability\", \"markovchain\", \n\t        function(object, t0, t1) {\n\t\t        out <- numeric(1)\n\t\t        fromState <- which(object@states == t0)\n\t\t        toState <- which(object@states == t1)\n\t\t        out <- ifelse(object@byrow == TRUE, object@transitionMatrix[fromState, toState] , \n\t\t                      object@transitionMatrix[toState, fromState])\n\t\t        return(out)\n\t        }\n)\n\n#  print, plot and show methods\n\n.showInt <- function(object, verbose = TRUE) {\n\t\n  # find the direction\n  if (object@byrow == TRUE) {\n\t  direction <- \"(by rows)\" \n\t} else {\n\t  direction <- \"(by cols)\" \n\t}\n  \n\tif (verbose == TRUE) {\n\t  cat(object@name, \"\\n A \", dim(object), \"- dimensional discrete Markov Chain defined by the following states: \\n\",\n\t      paste(states(object), collapse=\", \"), \"\\n The transition matrix \", \n\t      direction, \" is defined as follows: \\n\")\n\t}\n  \n\tprint(object@transitionMatrix)\n\tcat(\"\\n\")\n}\n\n\n# show methods for markovchain and markovchain list objects \nsetMethod(\"show\", \"markovchain\",\n          function(object){\n            .showInt(object)\n          }\n)\n\nsetMethod(\"show\", \"markovchainList\",\n          function(object) {\n\t\t        cat(object@name, \" list of Markov chain(s)\", \"\\n\")\n            for(i in 1:length(object@markovchains)) {\n              cat(\"Markovchain \",i,\"\\n\")\n              show(object@markovchains[[i]])\n            }\n          }\n)\n\n# print methods\nsetMethod(\"print\", \"markovchainList\", function(x) show(x))\nsetMethod(\"print\", \"markovchain\",\n          function(x){\n           object <- x\n\t\t       .showInt(object, verbose = FALSE)\n          }\n)\n\n.getNet <- function(object, round = FALSE) {\n \t\n  # function to get the absorbency matrix to plot and export to igraph\n\t#\n \t# Args: \n\t# object: a markovchain object\n\t# round: boolean to round\n \t#\n\t# Returns:\n\t#\n\t# a graph adjacency\n  \n\tif (object@byrow == FALSE) {\n\t  object <- t(object)\n\t}\n  \n\tmatr <- object@transitionMatrix*100\n\tif(round == TRUE) {\n\t  matr <- round(matr, 2)\n\t}\n\t\n\tnet <- graph.adjacency(adjmatrix = matr, weighted = TRUE, mode = \"directed\")\n\treturn(net)\n}\n\n\n# Plot methods for markovchain objects\n\n# plot method from stat5\nsetMethod(\"plot\", signature(x = \"markovchain\", y = \"missing\"),\n\t\t      function(x, y, package = \"igraph\", ...) {\n\t\t        switch(package,\n\t\t         \n\t\t         diagram = {\n\t\t           if (requireNamespace(\"diagram\", quietly = TRUE)) {\n\t\t             .plotdiagram(object = x, ...)\n\t\t           } else {\n\t\t             netMc <- .getNet(object = x, round = TRUE)\n\t\t             edgeLabel <- round(E(netMc)$weight / 100, 2)\n\t\t             plot.igraph(x = netMc, edge.label = edgeLabel, ...)\n\t\t           }\n\t\t         },\n\t\t         \n\t\t         DiagrammeR = {\n\t\t           if (requireNamespace(\"DiagrammeR\", quietly = TRUE)) {\n\t\t             .plotDiagrammeR(object = x, ...)\n\t\t           } else {\n\t\t             netMc <- .getNet(object = x, round = TRUE)\n\t\t             edgeLabel <- round(E(netMc)$weight / 100, 2)\n\t\t             plot.igraph(x = netMc, edge.label = edgeLabel, ...)\n\t\t           }\n\t\t         },\n\t\t         \n\t\t         {\n\t\t           netMc <- .getNet(object = x,round = TRUE)\n\t\t           edgeLabel <- round(E(netMc)$weight / 100, 2)\n\t\t           plot.igraph(x = netMc, edge.label = edgeLabel, ...)\n\t\t         })\n\t\t}\n)\n\n\n# @TAE: create an internal function that does this. Check also if the canonic form function \n#       is appropriate\n# method to convert into canonic form : a markovchain object\n# TODO: check meaning of this function\n\n#' @rdname absorbingStates\n#' \n#' @export\nsetGeneric(\"canonicForm\", function(object) standardGeneric(\"canonicForm\"))\nsetMethod(\"canonicForm\", \"markovchain\",\n          function(object) {\n            # Obtain the canonical form Q of a stochastic matrix P\n            P <- object@transitionMatrix\n            \n            # Uses the internal function commclassesKernelRcpp\n            comclasList <- .commclassesKernelRcpp(P)\n            \n            # vu is a row vector of 0s and 1s. vu(i) = 1 if\n            # the class C(i) is closed, and 0 otherwise\n            vu <- comclasList$v\n\t\t\t\n            # find index of closed communicating classes\n            u <- matlab::find(vu == TRUE)\n            \n            # find index of open communicating classes\n            w <- matlab::find(vu == FALSE)\n            \n            # Cmatr(i,j) is 1 if and only if j is in the\n            # communicating class of i.\n            Cmatr <- comclasList$C\n            \n            # R is now the set of representatives of closed classes\n            # Each closed class has a unique representative in R.\n            R <- numeric()\n            while(length(u) > 0) {\n              # everytime add a unique closed communicating classes index\n              R <- c(R, u[1])\n              \n              # remove the duplicate communication classes as u[1]\n              vu <- as.logical(vu * (Cmatr[u[1], ] == FALSE))\n              \n              # rest communicating classes index are hidden inside u\n              u <- find(vu == TRUE);\n            }\n            \n            # we have now a permutation p of indices, p, that\n            # gives the new stochastic matrix Q.\n            p <- numeric()\n            for (i in 1:length(R))\n            {\n              a <- find(Cmatr[R[i], ])\n              p <- c(p,a)\n            }\n            \n            # append open communicating classes index\n            p <- c(p, w)\n            \n            # extract canonical form out of given matrix using \n            # permutation of indexes calculated above\n            Q <- P[p, p]\n            \n            out <- new(\"markovchain\", transitionMatrix = Q, name = object@name)\n            return(out)\n          }\n)\n\n.canonicForm <- function(object) {\n  # Obtain the canonical form Q of a stochastic matrix P\n  P <- object@transitionMatrix\n  \n  # Uses the internal function commclassesKernelRcpp\n  comclasList <- .commclassesKernelRcpp(P)\n  \n  # vu is a row vector of 0s and 1s. vu(i) = 1 if\n  # the class C(i) is closed, and 0 otherwise\n  vu <- comclasList$v\n  \n  # find index of closed communicating classes\n  u <- matlab::find(vu == TRUE)\n  \n  # find index of open communicating classes\n  w <- matlab::find(vu == FALSE)\n  \n  # Cmatr(i,j) is 1 if and only if j is in the\n  # communicating class of i.\n  Cmatr <- comclasList$C\n  \n  # R is now the set of representatives of closed classes\n  # Each closed class has a unique representative in R.\n  R <- numeric()\n  while(length(u) > 0) {\n    # everytime add a unique closed communicating classes index\n    R <- c(R, u[1])\n    \n    # remove the duplicate communication classes as u[1]\n    vu <- as.logical(vu * (Cmatr[u[1], ] == FALSE))\n    \n    # rest communicating classes index are hidden inside u\n    u <- find(vu == TRUE);\n  }\n  \n  # we have now a permutation p of indices, p, that\n  # gives the new stochastic matrix Q.\n  p <- numeric()\n  for (i in 1:length(R))\n  {\n    a <- find(Cmatr[R[i], ])\n    p <- c(p,a)\n  }\n  \n  # append open communicating classes index\n  p <- c(p, w)\n  \n  # extract canonical form out of given matrix using \n  # permutation of indexes calculated above\n  Q <- P[p, p]\n  \n  out <- new(\"markovchain\", transitionMatrix = Q, name = object@name)\n  return(out)\n}\n\n# summary method for markovchain class\n# lists: closed, transient classes, irreducibility, absorbint, transient states\nsetMethod(\"summary\", signature(object = \"markovchain\"),\n\t\t      function(object){\n\t\t\t      \n\t\t        # list of closed, recurrent and transient classes\n\t\t        outs <- .summaryKernelRcpp(object)\n\t\t\t      \n\t\t        # display name of the markovchain object\n\t\t\t      cat(object@name,\" Markov chain that is composed by:\", \"\\n\")\n\t\t\t      \n\t\t\t      # number of closed classes\n\t\t\t      check <- length(outs$closedClasses)\n\t\t\t      \n\t\t\t      cat(\"Closed classes:\",\"\\n\")\n\t\t\t      \n\t\t\t      # display closed classes\n\t\t\t      if(check == 0) cat(\"NONE\", \"\\n\") else {\n\t\t\t\t      for(i in 1:check) cat(outs$closedClasses[[i]], \"\\n\")\n\t\t\t      }\n\t\t\t      \n\t\t\t      # number of recurrent classes\n\t\t\t      check <- length(outs$recurrentClasses)\n\t\t\t\n\t\t\t      cat(\"Recurrent classes:\", \"\\n\")\n\t\t\t      \n\t\t\t      # display recurrent classes\n\t\t\t      if(check == 0) cat(\"NONE\", \"\\n\") else {\n\t\t\t          cat(\"{\")\n\t\t\t          cat(outs$recurrentClasses[[1]], sep = \",\")\n\t\t\t          cat(\"}\")\n\t\t\t          if(check > 1) {\n\t\t\t            for(i in 2:check) {\n\t\t\t              cat(\",{\")\n\t\t\t              cat(outs$recurrentClasses[[i]], sep = \",\")\n\t\t\t              cat(\"}\")\n\t\t\t            }\n\t\t\t          }\n\t\t\t          cat(\"\\n\")\n\t\t\t      }\n\t\t\t      \n\t\t\t      # number of transient classes\n\t\t\t      check <- length(outs$transientClasses)\n\t\t\t      \n\t\t\t      cat(\"Transient classes:\",\"\\n\")\n\t\t\t\n\t\t\t      # display transient classes\n\t\t\t      if(check == 0) cat(\"NONE\", \"\\n\") else {\n\t\t\t          cat(\"{\")\n\t\t\t          cat(outs$transientClasses[[1]], sep = \",\")\n\t\t\t          cat(\"}\")\n\t\t\t          if(check > 1) { \n\t\t\t            for(i in 2:check) {\n\t\t\t              cat(\",{\")\n\t\t\t              cat(outs$transientClasses[[i]], sep = \",\")\n\t\t\t              cat(\"}\")\n\t\t\t            }\n\t\t\t          }\n\t\t\t          cat(\"\\n\")\n\t\t\t      }\n\t\t\t\n\t\t\t      # bool to say about irreducibility of markovchain\n\t\t\t      irreducibility <- is.irreducible(object)\n\t\t\t      \n\t\t\t      if(irreducibility) \n\t\t\t        cat(\"The Markov chain is irreducible\", \"\\n\") \n\t\t\t      else cat(\"The Markov chain is not irreducible\", \"\\n\")\n\t\t\t      \n\t\t\t      # display absorbing states\n\t\t\t      check <- absorbingStates(object)\n\t\t\t      if(length(check) == 0) check <- \"NONE\"\n\t\t\t      cat(\"The absorbing states are:\", check )\n\t\t\t      cat(\"\\n\")\n\t\t\t      \n\t\t\t      # return outs\n\t\t\t      # useful when user will assign the value returned\n\t\t\t      invisible(outs) \n          }\n)\n\n##################################################AS METHODS#########################\n\n.checkMatrix <- function(matr, byrow = TRUE, verbose = FALSE) {\n\t\n  # first check: size\n\tif (dim(matr)[1] != dim(matr)[2]) {\n\t\tif(verbose) stop(\"Error! Rectangular matrix\")\n\t\treturn(FALSE)\n\t}\n\t\n\t# second check: all elements are probs\n\tfor(i in 1:nrow(matr)) {\n\t\tfor(j in 1:ncol(matr)){\n\t\t\tif(!(.isProbRcpp(matr[i, j]))) {\n\t\t\t\tif(verbose) stop(\"Error! Non probabilities\")\n\t\t\t\t  return(FALSE)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t# third check: either columns or rows sum to one\n  # to perform only one check \t\n\tif(byrow == FALSE) {\n\t  matr <- t(matr) \n\t}\n\t\n  # calculate row's sum\n\tcheck <- rowSums(matr)\n\t\n\tfor( i in 1:length(check)) {\n\t  if (abs(1-check[i]) > .Machine$double.eps) {\n\t    if(verbose) {\n\t      stop(\"Error! Either rows or cols should sum to 1\") \n\t    }\n\t    \n\t    return(FALSE)\n\t  }\n\t}\n\t\n\t# if all test are passed\n\treturn(TRUE)\n}\n\n# Internal function to return a markovchain object given a matrix\n.matrix2Mc <- function(from) {\n\t\n  # whether given matrix is a transition matrix or not\n  # if it is then how probabilities are stored\n  # row-wise or columnwise\n  \n\tbyrow <- FALSE\n\tcheckByRow <- .checkMatrix(from, byrow = TRUE)\n\t\n\tif(checkByRow) {\n\t  byrow <- TRUE\n\t} else  {\n\t\tcheckByCols <- .checkMatrix(from, byrow = FALSE)\n\t\tif(!checkByCols) {\n\t\t  stop(\"Error! Not a probability matrix\")\t\n\t\t}\n\t}\n\t\n\t# extract states names\n\tif(byrow == TRUE) {\n\t  namesCandidate <- rownames(from) \n\t} else {\n\t  namesCandidate <- colnames(from)\n\t}\n\t\n\t# if states names is not there create it s1, s2, s3, ....\n\tif(is.null(namesCandidate)) {\n\t\tnamesCandidate <- character()\n\t\tfor(i in 1:nrow(from)) {\n\t\t  namesCandidate <- c(namesCandidate, paste(\"s\", i, sep = \"\")) \n\t\t}\n\t}\n\t\n\t# create markovchain object\n\tout <- new(\"markovchain\", transitionMatrix = from, states = namesCandidate, byrow = byrow)\n\t\n\tinvisible(out)\n}\n\n\n# coerce matrix to markovchain object using internal method\n# example: as(\"some matrix\", \"markovchain\")\nsetAs(from = \"matrix\", to = \"markovchain\", def = .matrix2Mc)\n\n# Function to transform a markovchain into a data.frame\n# Args:\n# from: a markovchain object\n#\n# returns:\n# a data.frame\n.mc2Df <- function(from) {\n  \n  # number of rows or columns\n\tnr <- nrow(from@transitionMatrix)\n\tfor(i in 1:nr){\n\t\tfor(j in 1:nr){\n\t\t\tt0 <- from@states[i]\n\t\t\tt1 <- from@states[j]\n\t\t\tprob <- transitionProbability(object = from, t0 = t0, t1 = t1)\n\t\t\trowDf <- data.frame(t0 = t0, t1 = t1, prob = prob)\n\t\t\t\n\t\t\t# go to else part if first row of data frame is generated\n\t\t\tif(exists(\"outDf\")) {\n\t\t\t  outDf <- rbind(outDf, rowDf)\n\t\t\t} else {\n\t\t\t  outDf <- rowDf\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn(outDf)\n}\n\n# method to convert(coerce) from markovchain to data.frame\nsetAs(from = \"markovchain\", to = \"data.frame\", def = .mc2Df)\n\n# method to find the column which stores transition probability\n.whichColProb <- function(df) {\n\t\n  # column number which stores transition probability\n  out <- 0\n  \n  # check for validity of data frame\n\tif(ncol(df) > 3) {\n\t  warning(\"Warning! More than three columns. Only the first three will be used\")\n\t}\n  \n\tif(ncol(df) < 3) {\n\t  stop(\"Error! Three columns needed\")\n\t}\n\t\n\tfor(i in 1:ncol(df)) {\n\t    \n\t  # when found the first numeric and probability col\n\t\t\tif((class(df[, i]) == \"numeric\") & (all(sapply(df[, i], .isProbRcpp) == TRUE))) {\n\t\t\t\t\tout <- i\n\t\t\t\t\tbreak\n\t\t\t}\n\t}\n  \n\treturn(out)\n}\n\n# Function to convert from a data.frame containing initial, ending \n#    and probability columns to a proper markovchain object\n#\n# Args:\n# from: a data.frame\n#\n# Returns:\n# A markovchain object \n\n.df2Mc <- function(from) {\n\t\n\tstatesNames <- unique(from[, 1])\n\tcolProb <- .whichColProb(from) # what is the use\n\t\n\t# transition matrix\n\tprMatr <- zeros(length(statesNames))\n\trownames(prMatr) <- statesNames\n\tcolnames(prMatr) <- statesNames\n\t\n\t\n\tfor(i in 1:nrow(from)) {\n\t\tidRow <- which(statesNames == from[i, 1]) # assume first col from\n\t\tidCol <- which(statesNames == from[i, 2]) # assume second col to\n\t\tprMatr[idRow, idCol] <- from[i, 3]        # assume third col t-probability\n\t}\n\t\n \tout <- new(\"markovchain\", transitionMatrix = prMatr)\n\treturn(out)\n}\n\n# method to convert(coerce) data frame to markovchain object \nsetAs(from = \"data.frame\", to = \"markovchain\", def = .df2Mc)\n\n\n# example\n# data <- data.frame(from = c(\"a\", \"a\", \"b\", \"b\", \"b\", \"b\"), \n#                      to = c(\"a\", \"b\", \"b\", \"b\", \"b\", \"a\"))\n# \n# from <- table(data)\n# .table2Mc(from)\n\n.table2Mc <- function(from) {\n\t\n  # check whether table has square dimension or not\n\tif(dim(from)[1] != dim(from)[2]) {\n\t  stop(\"Error! Table is not squared\")\n\t}\n  \n  # rows ond columns name should be same\n\tif(!setequal(rownames(from),colnames(from))) {\n\t  stop(\"Error! Rows not equal to coulumns\")\n\t}\n  \n  temp <- unclass(as.matrix(from))\n  \n  # make same sequence of col / row\n\tfromMatr <- temp[, order(rownames(temp))]\n\t\n\t# obtain transition matrix\n\toutMatr <- fromMatr / rowSums(fromMatr)\n\t\n\tout <- new(\"markovchain\", states = rownames(temp), \n\t           transitionMatrix = outMatr, byrow=TRUE)\n\t\n\treturn(out)\n}\n\n# coerce table to markovchain object\nsetAs(from = \"table\", to = \"markovchain\", def = .table2Mc)\n\n\n# function from msm to markovchain\n# msm is a package. Use this package to create msm object.\n# see how to create msm object using ?msm\n\n.msm2Mc <- function(from) {\n  temp <- msm::pmatrix.msm(from)\n  prMatr <- unclass(as.matrix(temp))\n  out <- new(\"markovchain\", transitionMatrix = prMatr)\n  return(out)\n}\n\n# coerce msm object to markovchain object\nsetAs(from = \"msm\", to = \"markovchain\", def = .msm2Mc)\n\n\n# function for msm.est to mc. Assume a probability matrix given\n.msmest2Mc <- function(from) {\n  \n  if (is.matrix(from)) {\n    # central estimate\n    pMatr <- from \n  }\n    \n  if (is.list(from)) {\n    # central estimate\n    pMatr <- from[[1]] \n  }\n    \n  out <- new(\"markovchain\", transitionMatrix = as(pMatr, \"matrix\"))\n  \n  return(out)\n}\n\n# coerce ms.est to markovchain object\nsetAs(from = \"msm.est\", to = \"markovchain\", def = .msmest2Mc)\n\n\n# function from etm to markovchain\n.etm2Mc<-function(from) {\n  \n  # data frame consists of  'from' and 'to' column\n  df <- from$trans\n  \n  # name of states\n  elements <- from$state.names\n  # number of unique states\n  nelements <- length(elements)\n  \n  # temporary t-matrix\n  prMatr <- matlab::zeros(nelements)\n  dimnames(prMatr) <- list(elements, elements)\n  \n  # populate t-matrix\n  for(i in 1:dim(df)[1]) {\n    r <- df[i, ] # each row one by one\n    stateFrom <- r$from\n    stateTo <- r$to\n    prMatr[stateFrom, stateTo] <- prMatr[stateFrom, stateTo] + 1\n  }\n  \n  # convert freq-matrix to trans-matrix\n  rsums <- rowSums(prMatr)\n  prMatr <- prMatr / rsums\n  \n  # take care of rows with all entries 0\n  if(any(rsums == 0)) {\n    indicesToBeSanitized <- which(rsums == 0)\n    \n    for(i in indicesToBeSanitized) {\n      for(j in 1:nelements) {\n        prMatr[i, j] <- 1 / nelements\n      }\n    }\n  }\n  \n  # create markovchain object\n  out <- new(\"markovchain\", transitionMatrix = prMatr)\n  return(out)\n}\n\n# coerce etm object to markovchain object\nsetAs(from = \"etm\", to = \"markovchain\", def = .etm2Mc)\n\n\n# functions and methods to return a matrix\n.mc2matrix <- function(from) {\n\tout <- from@transitionMatrix\n\treturn(out)\n}\n\n# coerce markovchain object to matrix(transition)\nsetAs(from = \"markovchain\", to = \"matrix\", def = .mc2matrix)\n\n\n# functions and methods to return a matrix\n.mc2igraph <- function(from) {\n  \n  # convert the markovchain to data.frame\n\ttemp <- .mc2Df(from=from) \n\t\n\t# convert the data frame to igraph graph\n\t# need to set only non zero weights\n\tout <- graph.data.frame(d=temp[temp$prob>0,]) \n\treturn(out)\n}\n\n# coerce markovchain object to igraph\nsetAs(from = \"markovchain\", to = \"igraph\", def = .mc2igraph)\n\n\n# transposing method for markovchain objects\nsetMethod(\"t\", \"markovchain\", \n\t\t      function(x) { \n\t\t\t      out <- new(\"markovchain\", byrow = !x@byrow, \n\t\t\t                 transitionMatrix = t(x@transitionMatrix))\n\t\t\t      \n\t\t\t      return(out)\n\t\t      } \n)\n\n\n# function to multiplicate two markov chains\n#\n# Args:\n# e1: first markovchain\n# e2: second markov chain\n#\n# Returns:\n# if feasible, a markovchain where the transition matrix is e1*e2\n\nsetMethod(\"*\", c(\"markovchain\", \"markovchain\"),\n          function(e1, e2) {\n            \n            # compare states of markovchains\n\t          if(!setequal(e1@states, e2@states)) {\n\t            warning(\"Warning! Different states\")\n\t          }\n            \n            # dimension must be equal\n\t\t\t      if(!setequal(dim(e1@transitionMatrix), dim(e2@transitionMatrix))) {\n\t\t\t        stop(\"Error! Different size\")\n\t\t\t      }\n\t\t\t\n            # both must be either row wise or col wise\n            if(!(e1@byrow == e2@byrow)) {\n              stop(\"Error! Both transition matrix should be defined either by row or by column\")\n            }\n\t\t\n            newStates <- e1@states\n\t\t\t      newTransMatr <- e1@transitionMatrix %*% e2@transitionMatrix\n\t\t\t      byRow <- e1@byrow\n\t\t\t      # multiplicated matrix takes the first matrix's name\n\t\t\t      mcName <- e1@name \n\t\t\t      \n\t\t\t      out<-new(\"markovchain\", states = newStates, transitionMatrix = newTransMatr, \n\t\t\t               byrow = byRow, name = mcName)\n\t\t\t      \n\t\t\t      return(out)\n          }\n)\n\n# methods implemented for multiplication of markovchain object with \n# matrix, 1-D vector, and vice-versa\n\nsetMethod(\"*\", c(\"matrix\", \"markovchain\"),\n\t\t      function(e1, e2) {\n\t\t\t      out <- e1 %*% e2@transitionMatrix\n\t\t\t      return(out)\n\t\t      }\n)\n\nsetMethod(\"*\", c(\"markovchain\", \"matrix\"),\n\t\t      function(e1, e2) {\n\t\t\t      out <- e1@transitionMatrix %*% e2\n\t\t\t      return(out)\n          }\n)\n\nsetMethod(\"*\", c(\"numeric\", \"markovchain\"),\n\t\t      function(e1, e2) {\n\t\t\t      if(length(e1) != dim(e2)) {\n\t\t\t        stop(\"Error! Uncompatible dimensions\")\n\t\t\t      } else {\n\t\t\t        out <- e1 %*% e2@transitionMatrix\n\t\t\t      }\n\t\t        \n\t\t\t      return(out)\n\t\t      }\n)\n\nsetMethod(\"*\", c(\"markovchain\", \"numeric\"),\n\t\t      function(e1, e2) {\n\t\t\t      if(length(e2) != dim(e1)) {\n\t\t\t        stop(\"Error! Uncompatible dimensions\")\n\t\t\t      } else {\n\t\t\t        out <- e1@transitionMatrix %*% e2\n\t\t\t      }\n\t\t        \n\t\t\t       return(out)\n\t\t      }\n)\n\n# compare two markovchain object\nsetMethod(\"==\", c(\"markovchain\", \"markovchain\"),\n          function(e1, e2) {\n            out <- FALSE\n            out <- identical(e1@transitionMatrix, e2@transitionMatrix)\n            return(out)\n          }\n)\n\nsetMethod(\"!=\", c(\"markovchain\", \"markovchain\"),\n          function(e1, e2) {\n            out <- FALSE\n            out <- !(e1 == e2)\n            return(out)\n          }\n)\n\n# markovchain raise to some power\nsetMethod(\"^\", c(\"markovchain\", \"numeric\"),\n          function(e1, e2) {\n            out <- new(\"markovchain\", states = e1@states, byrow = e1@byrow,\n                       transitionMatrix = e1@transitionMatrix %^% e2,\n                       name = paste(e1@name, \"^\", e2, sep = \"\")\n                      )\n            \n            return(out)\n          }\n)\n\n\n# methods to directly access transition matrix elements\nsetMethod(\"[\", signature(x = \"markovchain\", i = \"ANY\", j = \"ANY\"),\n          function(x, i, j) {\n            out <- x@transitionMatrix[i, j]\n            return(out)\n          }\n)\n\n# methods to directly access markovchain objects composing a markovchainList object\nsetMethod(\"[[\", signature(x = \"markovchainList\", i = \"ANY\"),\n\t\t      function(x, i) {\n\t\t\t      out <- x@markovchains[[i]]\n            return(out)\n\t\t      }\n)\n\n# transition probabilty vector from a given state\n\n#' @title \\code{conditionalDistribution} of a Markov Chain\n#' \n#' @name conditionalDistribution\n#' \n#' @description It extracts the conditional distribution of the subsequent state, \n#'              given current state.\n#' \n#' @param object A \\code{markovchain} object.\n#' @param state Subsequent state.\n#' \n#' @author Giorgio Spedicato, Deepak Yadav\n#' \n#' @return A named probability vector\n#' @references A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010\n#' \n#' @seealso \\code{\\linkS4class{markovchain}}\n#' \n#' @examples \n#' # define a markov chain\n#' statesNames <- c(\"a\", \"b\", \"c\")\n#' markovB <- new(\"markovchain\", states = statesNames, transitionMatrix = \n#'                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1),nrow = 3, \n#'                       byrow = TRUE, dimnames = list(statesNames, statesNames)))\n#'                       \n#' conditionalDistribution(markovB, \"b\")                       \n#' \n#' @export\nsetGeneric(\"conditionalDistribution\", function(object, state) standardGeneric(\"conditionalDistribution\"))\nsetMethod(\"conditionalDistribution\", \"markovchain\",\n          function(object, state) {\n            # get the states names\n\t\t\t      stateNames <- states(object) \n\t\t\t      \n\t\t\t      # number of unique states\n\t\t\t      out <- numeric(length(stateNames))\n\t\t\t      \n\t\t\t      # states are assumed to be sorted\n\t\t\t      index2Take <- which(stateNames == state) \n\t\t\t      \n\t\t\t      if(object@byrow == TRUE) {\n\t\t\t\t      out <- object@transitionMatrix[index2Take, ]\n\t\t\t      } else {\n\t\t\t\t      out <- object@transitionMatrix[, index2Take]\n\t\t\t      }\n\t\t\t      \n\t\t\t      # names the output and returs it\n\t\t\t      names(out) <- stateNames\n\t\t\t      \n\t\t\t      return(out) \n\t\t      }\n)\n\t\t  \n# Function to get the mode of a probability vector\n# \n# Args:\n# probVector: the probability vector\n# ties: specifies if ties are to be sampled, otherwise more than one element is returned\n#\n# Returns:\n# the name of the model element\n\n.getMode <- function(probVector, ties = \"random\") {\n\t\n\tmaxIndex <- which(probVector == max(probVector))\n\ttemp <- probVector[maxIndex] # index of maximum probabilty\n\t\n\tif((ties == \"random\") & (length(temp) > 1)) {\n\t  out <- sample(temp, 1) \n\t} else {\n\t  out <- temp\n\t}\n\t\n\treturn(names(out))\n}\n\n# predict method for markovchain objects\n# given initial state return a vector of next n.ahead states\n\nsetMethod(\"predict\", \"markovchain\", \n\t\t      function(object, newdata, n.ahead = 1) {\n\t\t        # identify the last state\n\t\t\t      lastState <- newdata[length(newdata)]\n            out <- character()\n            \n            for(i in 1:n.ahead) {\n              # cyclically determine the most probable subsequent state from the conditional distribution\n              newState <- .getMode(probVector = conditionalDistribution(object, lastState), ties = \"random\") \n              out <- c(out, newState)\n              lastState <- newState\n            }\n            \n            return(out)\n          }\n)\n\n# predict method for markovchainList objects\nsetMethod(\"predict\", \"markovchainList\",\n\t\t      definition = function(object, newdata, n.ahead = 1, continue = FALSE) {\n\t\t\t    # object a markovchainList\n\t\t      # newdata = the actual data \n\t\t      # n.ahead = how much ahead \n\t\t      # continue = veryfy if that lasts\n\t\t        \n\t\t                      # allocate output\n\t\t\t                    out <- character() \n\t\t\t                    actualPos <- length(newdata) \n\t\t\t                    lastState <- newdata[actualPos] # take last position\n\t\t\t                    for(i in 1:n.ahead) {\n\t\t\t\t                    newPos <- actualPos + i - 1\n\t\t\t\t                    if(newPos <= dim(object)) {\n\t\t\t\t\t                    newState <- predict(object = object[[newPos]], newdata = lastState, n.ahead = 1)\n\t\t\t\t\t                    out <- c(out, newState)\n\t\t\t\t\t                    lastState <- newState\n\t\t\t\t                    } else {\n\t\t\t\t\t                      if(continue == TRUE) {\n\t\t\t\t\t\t                      newState <- predict(object = object[[dim(object)]], newdata = lastState, n.ahead = 1)\n\t\t\t\t\t\t                      out <- c(out, newState)\n\t\t\t\t\t\t                      lastState <- newState\n\t\t\t\t\t                      } else break;\n\t\t\t\t                      }\n\t\t\t                    }\n\t\t\t\n\t\t\t                    return(out)\n\t\t                   }\n)\n",
    "created" : 1486723581156.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3266576442",
    "id" : "ABF34376",
    "lastKnownWriteTime" : 1482925794,
    "last_content_update" : 1482925794,
    "path" : "/media/vandit/New Volume/study/programming/gsoc/markovchain/R/0_classesAndMethods.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}